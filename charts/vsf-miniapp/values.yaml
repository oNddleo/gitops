# Default values for vsf-miniapp
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# ============================================================================
# Service Identity (MUST be overridden in service-specific values)
# ============================================================================
serviceName: "default-service"  # Override this with actual service name (service-a, service-b, etc.)
language: "generic"  # Override with: java, nodejs, python, golang, etc.
runtime: ""  # Override with: openjdk-17, node-20, python-3.11, etc.

# ============================================================================
# Scaling Configuration
# ============================================================================
# Replica count
replicaCount: 3

# Image configuration
image:
  repository: YOUR_ECR_REGISTRY/vsf-miniapp-default  # Override with service-specific repository
  pullPolicy: IfNotPresent
  tag: "latest"  # Overridden by CI/CD

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# Service account
serviceAccount:
  create: true
  annotations:
    # IRSA annotation for AWS Secrets Manager access
    eks.amazonaws.com/role-arn: "arn:aws:iam::ACCOUNT_ID:role/gitops-eks-cluster-secrets-csi-driver"  # UPDATE THIS
  name: ""

# Pod annotations
podAnnotations:
  # Enable Linkerd sidecar injection
  linkerd.io/inject: enabled
  # Enable Reloader for ConfigMap/Secret changes
  reloader.stakater.com/auto: "true"

# Pod security context
podSecurityContext:
  runAsNonRoot: true
  runAsUser: 1000
  fsGroup: 1000
  seccompProfile:
    type: RuntimeDefault

# Container security context
securityContext:
  allowPrivilegeEscalation: false
  readOnlyRootFilesystem: true
  runAsNonRoot: true
  runAsUser: 1000
  capabilities:
    drop:
      - ALL

# Service configuration
service:
  type: ClusterIP
  port: 80
  targetPort: 8080
  annotations: {}

# Ingress configuration using Traefik IngressRoute
ingress:
  enabled: true
  className: traefik
  annotations: {}
  hosts:
    - host: myapp.example.com  # UPDATE THIS
      paths:
        - path: /
          pathType: Prefix
  tls:
    enabled: true
    secretName: myapp-tls

# Resources
resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

# Autoscaling
autoscaling:
  enabled: true
  minReplicas: 3
  maxReplicas: 10
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80

# Liveness and readiness probes
livenessProbe:
  httpGet:
    path: /healthz
    port: 8080
  initialDelaySeconds: 30
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready
    port: 8080
  initialDelaySeconds: 10
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 3

# Node selector
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity - pod anti-affinity for HA
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - vsf-miniapp
          topologyKey: kubernetes.io/hostname

# Environment variables
env:
  - name: APP_NAME
    value: "vsf-miniapp"
  - name: APP_VERSION
    value: "1.0.0"
  - name: LOG_LEVEL
    value: "info"
  - name: PORT
    value: "8080"

# Environment variables from ConfigMap
envFrom:
  - configMapRef:
      name: vsf-miniapp-config
  - secretRef:
      name: vsf-miniapp-secrets

# ConfigMap data
configMap:
  enabled: true
  data:
    app.properties: |
      app.name=vsf-miniapp
      app.environment=production
      feature.flag.enabled=true

# AWS Secrets Manager via CSI Driver
secretsManager:
  enabled: true
  region: us-east-1  # UPDATE THIS
  mountPath: /mnt/secrets

  # Define which secrets to retrieve from AWS Secrets Manager
  objects:
    - objectName: "production/myapp/database"
      objectType: "secretsmanager"
      jmesPath:
        - path: url
          objectAlias: database-url
        - path: username
          objectAlias: database-username
        - path: password
          objectAlias: database-password
    - objectName: "production/myapp/api-key"
      objectType: "secretsmanager"
      objectAlias: api-key

  # Sync to Kubernetes Secret for use in environment variables
  syncToKubernetesSecret: true

  # Map secret fields to Kubernetes Secret keys
  secretData:
    - objectName: database-url
      key: DATABASE_URL
    - objectName: database-username
      key: DATABASE_USERNAME
    - objectName: database-password
      key: DATABASE_PASSWORD
    - objectName: api-key
      key: API_KEY

# Persistent Volume
persistence:
  enabled: false
  storageClass: "gp3"
  accessMode: ReadWriteOnce
  size: 10Gi
  mountPath: /data

# Service mesh configuration
serviceMesh:
  enabled: true
  mTLS: true

# Monitoring
monitoring:
  enabled: true
  serviceMonitor:
    enabled: true
    interval: 30s
    path: /metrics
    port: metrics

# External Secrets Operator (disabled - we use AWS Secrets Manager CSI Driver instead)
externalSecrets:
  enabled: false
  refreshInterval: 1h
  secretStore:
    name: aws-secretsmanager
    kind: SecretStore
  data: []

# Additional volumes
volumes: []

# Additional volume mounts
volumeMounts:
  - name: tmp
    mountPath: /tmp
  - name: cache
    mountPath: /app/cache
